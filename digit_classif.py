# -*- coding: utf-8 -*-
"""digit_classif.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ShCa6c6WOuHAmLJx0j9o2DcO5a-qfJlk
"""

import pandas as pd
import numpy as np
from sklearn.datasets import load_digits

data = load_digits()
# data.data.shape

import matplotlib.pyplot as plt
plt.gray()
plt.matshow(data.images[0])

image = data.images
label = data.target
image.shape

from keras.utils import to_categorical

# Assuming your original labels are stored in the variable 'labels'
label = to_categorical(label)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(image, label, test_size=0.2, random_state=24)

print(X_train.shape)
print(y_train.shape)

# flatten_images = images.reshape(len(images))
X_train_flatten = X_train.reshape(len(X_train), 8*8)
X_test_flatten = X_test.reshape(len(X_test), 8*8)
print(X_train_flatten.shape)
print(y_train.shape)

from keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalization, Dropout
import tensorflow as tf
from tensorflow.keras.models import Sequential

model = Sequential()

# model.add(Conv2D(32, kernel_size=(3,3), padding='valid', activation='relu', input_shape=(flatten_images.shape)))
# model.add(BatchNormalization())
# model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

# model.add(Conv2D(64, kernel_size=(3,3), padding='valid', activation='relu'))
# model.add(BatchNormalization())
# model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

# model.add(Conv2D(128, kernel_size=(3,3), padding='valid', activation='relu'))
# model.add(BatchNormalization())
# model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

# model.add(Flatten())

model.add(Dense(32, activation='relu', input_shape=(64,)))
model.add(Dropout(0.1))
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.1))
model.add(Dense(10, activation='sigmoid'))

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

model.fit(X_train_flatten, y_train, epochs=10)

model.evaluate(X_test_flatten, y_test)

plt.matshow(X_test[0])

y_pred = model.predict(X_test_flatten)

print(y_pred[0])

np.argmax(y_pred[0])

y_pred_label = [np.argmax(i) for i in y_pred]

y_pred_label[0]

y_test[:5]

y_pred_label[:5]